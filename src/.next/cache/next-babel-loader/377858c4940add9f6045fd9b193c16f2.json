{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/array/is-array\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\"));\n\nvar _mergeWith = require('lodash.mergewith');\n\nvar _add = require('lodash.add');\n\nvar _omit = require('lodash.omit');\n\nvar _isEmpty = require('lodash.isempty');\n\nvar _isNumber = require('lodash.isnumber');\n\nvar _merge = require('lodash.merge');\n\nvar _keys = require('lodash.keys');\n\nvar _intersectionBy = require('lodash.intersectionby');\n\nvar pubg = require('../pubg_api/pubg');\n/**\n * @description Returns an array containing info about a player and their season stats,\n * as well as the matches played this season\n * @param {string[]} playerNames array with a string of player names to lookup\n * @param {string} seasonid the PUBG season id\n * @returns {Array<Promise<PlayerSeason>>|<Promise<PlayerSeason>>} array containgin player info and season stats\n */\n\n\nvar getPlayersSeasonStats =\n/*#__PURE__*/\nfunction () {\n  var _ref = (0, _asyncToGenerator2[\"default\"])(\n  /*#__PURE__*/\n  _regenerator[\"default\"].mark(function _callee(playerNames, seasonid) {\n    var players;\n    return _regenerator[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return pubg.getPlayer({\n              name: playerNames\n            });\n\n          case 2:\n            players = _context.sent;\n\n            if (!(0, _isArray[\"default\"])(players)) {\n              _context.next = 9;\n              break;\n            }\n\n            _context.next = 6;\n            return pubg.getManyPlayerSeason({\n              players: players\n            }, seasonid)[\"catch\"](function (err) {\n              throw err;\n            });\n\n          case 6:\n            _context.t0 = _context.sent;\n            _context.next = 12;\n            break;\n\n          case 9:\n            _context.next = 11;\n            return pubg.getPlayerSeason(players, seasonid)[\"catch\"](function (err) {\n              throw err;\n            });\n\n          case 11:\n            _context.t0 = _context.sent;\n\n          case 12:\n            return _context.abrupt(\"return\", _context.t0);\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getPlayersSeasonStats(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Combines the season stats of a group of players into their total aggregate\n * for each game mode, for a given season.\n * @param {PlayerSeason[]} playersStats an array of players that contains their stats for a season\n * @returns {Object} an object\n */\n\n\nvar getCombinedStats = function getCombinedStats(playersStats) {\n  // Declare the combined stats obj\n  var combinedStats = {\n    solo: {},\n    soloFPP: {},\n    duo: {},\n    duoFPP: {},\n    squad: {},\n    squadFPP: {}\n  }; // Sum the stats of the season of each player to get the squad total stats\n\n  playersStats.forEach(function (player) {\n    _mergeWith(combinedStats.solo, player.season.stats.solo, _add);\n\n    _mergeWith(combinedStats.soloFPP, player.season.stats.soloFPP, _add);\n\n    _mergeWith(combinedStats.duo, player.season.stats.duo, _add);\n\n    _mergeWith(combinedStats.duoFPP, player.season.stats.duoFPP, _add);\n\n    _mergeWith(combinedStats.squad, player.season.stats.squad, _add);\n\n    _mergeWith(combinedStats.squadFPP, player.season.stats.squadFPP, _add);\n  });\n  return combinedStats;\n};\n/**\n * @description Get the matches that the given players have played together\n * @param {PlayerSeason[]} playersStats an array of players that contains their stats for a season\n * @returns {Object} containing arrays of matches that the players in [playersStats] have in common,\n * separated by game mode (duo, duoFPP, squad, squadFPP)\n */\n\n\nvar getMatchesTogether = function getMatchesTogether(playersStats) {\n  var matchesTogether = {};\n  matchesTogether.duo = playersStats[0].season.matches.matchesDuo;\n  matchesTogether.duoFPP = playersStats[0].season.matches.matchesDuoFPP;\n  matchesTogether.squad = playersStats[0].season.matches.matchesSquad;\n  matchesTogether.squadFPP = playersStats[0].season.matches.matchesSquadFPP;\n\n  for (var i = 1; i < playersStats.length; i++) {\n    // Find duo matches that the players have in common\n    matchesTogether.duo = _intersectionBy(matchesTogether.duo, playersStats[i].season.matches.matchesDuo, 'id');\n    matchesTogether.duo = matchesTogether.duo.map(function (match) {\n      return match.fetch();\n    }); // Find duoFPP matches that the players have in common\n\n    matchesTogether.duoFPP = _intersectionBy(matchesTogether.duoFPP, playersStats[i].season.matches.matchesDuoFPP, 'id'); // Find squad matches that the players have in common\n\n    matchesTogether.squad = _intersectionBy(matchesTogether.squad, playersStats[i].season.matches.matchesSquad, 'id'); // Find squadFPP matches that the players have in common\n\n    matchesTogether.squadFPP = _intersectionBy(matchesTogether.squadFPP, playersStats[i].season.matches.matchesSquadFPP, 'id');\n  }\n\n  return matchesTogether;\n};\n/**\n * @description Get the stats of a group of players from the matches that they have played\n * together this season.\n * @param {String[]} playerNames Array of player names\n * @param {String} seasonid id of the season\n * @returns {Object} Object with stats of the players for each game mode\n */\n\n\nvar getSquadStatsFromMatches =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = (0, _asyncToGenerator2[\"default\"])(\n  /*#__PURE__*/\n  _regenerator[\"default\"].mark(function _callee3(matches, playerNames) {\n    var fetchedMatches, fullDuoMatches, fullDuoFPPMatches, fullSquadMatches, fullSquadFPPMatches, duoMatchesStats, duoFPPMatchesStats, squadMatchesStats, squadFPPMatchesStats;\n    return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return _promise[\"default\"].all(matches.map(\n            /*#__PURE__*/\n            function () {\n              var _ref3 = (0, _asyncToGenerator2[\"default\"])(\n              /*#__PURE__*/\n              _regenerator[\"default\"].mark(function _callee2(match) {\n                return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.next = 2;\n                        return pubg.getMatch(match.id);\n\n                      case 2:\n                        return _context2.abrupt(\"return\", _context2.sent);\n\n                      case 3:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function (_x5) {\n                return _ref3.apply(this, arguments);\n              };\n            }()));\n\n          case 2:\n            fetchedMatches = _context3.sent;\n            fullDuoMatches = fetchedMatches.filter(function (match) {\n              return match.attributes.gameMode === 'duo';\n            });\n            fullDuoFPPMatches = fetchedMatches.filter(function (match) {\n              return match.attributes.gameMode === 'duo-fpp';\n            });\n            fullSquadMatches = fetchedMatches.filter(function (match) {\n              return match.attributes.gameMode === 'squad';\n            });\n            fullSquadFPPMatches = fetchedMatches.filter(function (match) {\n              return match.attributes.gameMode === 'squad-fpp';\n            }); // Get the stats of the players from the duo matches\n\n            duoMatchesStats = getPlayersStatsFromMatches(fullDuoMatches, playerNames); // Get the stats of the players from the duo fpp matches\n\n            duoFPPMatchesStats = getPlayersStatsFromMatches(fullDuoFPPMatches, playerNames); // Get the stats of the players from the squad matches\n\n            squadMatchesStats = getPlayersStatsFromMatches(fullSquadMatches, playerNames); // Get the stats of the players from the squad fpp matches\n\n            squadFPPMatchesStats = getPlayersStatsFromMatches(fullSquadFPPMatches, playerNames);\n            return _context3.abrupt(\"return\", {\n              duo: {\n                gamesPlayed: fullDuoMatches.length,\n                wins: duoMatchesStats[playerNames[0]].wins,\n                top10s: duoMatchesStats[playerNames[0]].top10s,\n                stats: duoMatchesStats\n              },\n              duoFPP: {\n                gamesPlayed: fullDuoFPPMatches.length,\n                wins: duoFPPMatchesStats[playerNames[0]].wins,\n                top10s: duoFPPMatchesStats[playerNames[0]].top10s,\n                stats: duoFPPMatchesStats\n              },\n              squad: {\n                gamesPlayed: fullSquadMatches.length,\n                wins: squadMatchesStats[playerNames[0]].wins,\n                top10s: squadMatchesStats[playerNames[0]].top10s,\n                stats: squadMatchesStats\n              },\n              squadFPP: {\n                gamesPlayed: fullSquadFPPMatches.length,\n                wins: squadFPPMatchesStats[playerNames[0]].wins,\n                top10s: squadFPPMatchesStats[playerNames[0]].top10s,\n                stats: squadFPPMatchesStats\n              }\n            });\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function getSquadStatsFromMatches(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @description Return an object that contains an array for each game mode that contains the\n * aggregated stats of each squad member\n * @param {Match[]} matches An array of Match that the players have in common\n * @param {string[]} players Array of player names\n * @returns {Object} Object with player stats for each game mode\n */\n\n\nvar getPlayersStatsFromMatches = function getPlayersStatsFromMatches(matches, players) {\n  var squadStats = {\n    teamTotal: {}\n  };\n  players.forEach(function (player) {\n    squadStats[player] = {\n      wins: 0,\n      top10s: 0,\n      alive: 0,\n      suicides: 0,\n      zoneDeaths: 0,\n      badges: []\n    };\n  }); // Traverse the matches\n\n  for (var i = 0; i < matches.length; i++) {\n    var rosters = matches[i].relationships.rosters; // Traverse the rosters from the match\n\n    var _loop2 = function _loop2(j) {\n      var participants = rosters[j].relationships.participants; // If the roster contains any of the squad players process it, else -> search next roster\n\n      if (players.some(function (p) {\n        for (var _i = 0; _i < participants.length; _i++) {\n          if (p === participants[_i].attributes.stats.name) {\n            return true;\n          }\n        }\n\n        return false;\n      })) {\n        // Traverse the participants in the roster\n        for (var k = 0; k < participants.length; k++) {\n          var name = participants[k].attributes.stats.name; // If the participant is not part of the queried players, skip him\n\n          if (!players.includes(name)) continue; // Merge the stats obj of the player with the match stats\n\n          _mergeWith(squadStats[name], participants[k].attributes.stats, function (objValue, srcValue, key, object, source, stack) {\n            return sumPlayerStats(objValue, srcValue, key, object, source, stack);\n          }); // Merge the stats of a player with the team total if its a squad\n\n\n          _mergeWith(squadStats.teamTotal, participants[k].attributes.stats, function (objValue, srcValue, key, object, source, stack) {\n            return sumPlayerStats(objValue, srcValue, key, object, source, stack);\n          });\n        }\n      } else {\n        return \"continue\";\n      } // Roster was found, no need to keep iterating this match's rosters\n\n\n      return \"break\";\n    };\n\n    _loop: for (var j = 0; j < rosters.length; j++) {\n      var _ret = _loop2(j);\n\n      switch (_ret) {\n        case \"continue\":\n          continue;\n\n        case \"break\":\n          break _loop;\n      }\n    }\n  } // Add the badges for the players and return the updated object\n\n\n  return calculateBadges(squadStats);\n};\n/**\n * Function used to merge the objects for the player stats from each match\n * Parameters are the ones used for lodash's mergeWith function\n */\n\n\nvar sumPlayerStats = function sumPlayerStats(objValue, srcValue, key, object) {\n  if (key === 'longestKill') {\n    return objValue > srcValue ? objValue : srcValue;\n  } else if (key === 'winPlace') {\n    srcValue === 1 ? object.wins++ : null;\n    srcValue <= 10 ? object.top10s++ : null;\n  } else if (key === 'deathType') {\n    srcValue === 'byzone' ? object.zoneDeaths++ : srcValue === 'suicide' ? object.suicide++ : srcValue === 'alive' ? object.alive++ : null;\n  } else {\n    return _isNumber(objValue) ? objValue + srcValue : srcValue;\n  }\n};\n/**\n * @description Add the corresponding badges to each player in the squad stats\n * @param squadStats array of players and their stats for a given set of matches\n * @returns the updated squadStats obj with each player with their badges\n */\n\n\nvar calculateBadges = function calculateBadges(squadStats) {\n  if (_isEmpty(squadStats.teamTotal)) {\n    return squadStats;\n  } else {\n    // Get the top metrics and their value\n    var badges = [{\n      stat: 'assists',\n      description: 'Most Assists'\n    }, {\n      stat: 'damageDealt',\n      description: 'Most Damage Dealt'\n    }, {\n      stat: 'headshotKills',\n      description: 'Most Headshots'\n    }, {\n      stat: 'kills',\n      description: 'Most Kills'\n    }, {\n      stat: 'longestKill',\n      description: 'Longest Kill'\n    }, {\n      stat: 'revives',\n      description: 'Most Revives'\n    }, {\n      stat: 'roadKills',\n      description: 'Most Road Kills'\n    }, {\n      stat: 'swimDistance',\n      description: 'Most Distance Swimmed'\n    }, {\n      stat: 'teamKills',\n      description: 'Most Teamkills'\n    }, {\n      stat: 'timeSurvived',\n      description: 'Longest Time Survived'\n    }, {\n      stat: 'vehicleDestroys',\n      description: 'Most Vehicles Destroyed'\n    }, {\n      stat: 'walkDistance',\n      description: 'Most Distance Walked'\n    }, {\n      stat: 'suicides',\n      description: 'Most Suicides'\n    }, {\n      stat: 'weaponsAcquired',\n      description: 'Most Weapons Looted'\n    }, {\n      stat: 'zoneDeaths',\n      description: 'Most Zone Deaths'\n    }];\n\n    for (var i = 0; i < badges.length; i++) {\n      var topPlayer = getTopPlayer(squadStats, badges[i].stat);\n\n      if (topPlayer.player) {\n        squadStats[topPlayer.player].badges.push(_omit(_merge(topPlayer, badges[i]), 'player'));\n      }\n    }\n\n    return squadStats;\n  }\n};\n/**\n * @description Get the player name that has the highest score in a given metric\n * @param squadStats the stats obj of a group of players\n * @param metric the metric to be evaluated\n * @returns and object with the player index in the squadStat param and the value of the max metric\n */\n\n\nvar getTopPlayer = function getTopPlayer(squadStats, metric) {\n  squadArray = _keys(squadStats); // Get an array of player names from the squad\n\n  var topValue = 0;\n  var topPlayer = null; // Traverse the player names array\n\n  for (var i = 1; i < squadArray.length; i++) {\n    if (squadStats[squadArray[i]][metric] > topValue) {\n      topValue = squadStats[squadArray[i]][metric];\n      topPlayer = squadArray[i];\n    }\n  }\n\n  return {\n    stat: metric,\n    player: topPlayer,\n    value: topValue\n  };\n};\n\nmodule.exports = {\n  calculateBadges: calculateBadges,\n  getPlayersSeasonStats: getPlayersSeasonStats,\n  getCombinedStats: getCombinedStats,\n  getMatchesTogether: getMatchesTogether,\n  getSquadStatsFromMatches: getSquadStatsFromMatches\n};","map":{"version":3,"sources":["/Users/ivan/Documents/Developer/Portfolio-Projects/mypubgsquad/mypubgsquad-next/src/server/core/statsAnalysis.js"],"names":["_mergeWith","require","_add","_omit","_isEmpty","_isNumber","_merge","_keys","_intersectionBy","pubg","getPlayersSeasonStats","playerNames","seasonid","getPlayer","name","players","getManyPlayerSeason","err","getPlayerSeason","getCombinedStats","playersStats","combinedStats","solo","soloFPP","duo","duoFPP","squad","squadFPP","forEach","player","season","stats","getMatchesTogether","matchesTogether","matches","matchesDuo","matchesDuoFPP","matchesSquad","matchesSquadFPP","i","length","map","match","fetch","getSquadStatsFromMatches","all","getMatch","id","fetchedMatches","fullDuoMatches","filter","attributes","gameMode","fullDuoFPPMatches","fullSquadMatches","fullSquadFPPMatches","duoMatchesStats","getPlayersStatsFromMatches","duoFPPMatchesStats","squadMatchesStats","squadFPPMatchesStats","gamesPlayed","wins","top10s","squadStats","teamTotal","alive","suicides","zoneDeaths","badges","rosters","relationships","j","participants","some","p","k","includes","objValue","srcValue","key","object","source","stack","sumPlayerStats","calculateBadges","suicide","stat","description","topPlayer","getTopPlayer","push","metric","squadArray","topValue","value","module","exports"],"mappings":"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","sourcesContent":["const _mergeWith = require('lodash.mergewith');\nconst _add = require('lodash.add');\nconst _omit = require('lodash.omit');\nconst _isEmpty = require('lodash.isempty');\nconst _isNumber = require('lodash.isnumber');\nconst _merge = require('lodash.merge');\nconst _keys = require('lodash.keys');\nconst _intersectionBy = require('lodash.intersectionby');\nconst pubg = require('../pubg_api/pubg');\n\n/**\n * @description Returns an array containing info about a player and their season stats,\n * as well as the matches played this season\n * @param {string[]} playerNames array with a string of player names to lookup\n * @param {string} seasonid the PUBG season id\n * @returns {Array<Promise<PlayerSeason>>|<Promise<PlayerSeason>>} array containgin player info and season stats\n */\nconst getPlayersSeasonStats = async (playerNames, seasonid) => {\n  const players = await pubg.getPlayer({ name: playerNames });\n  return Array.isArray(players)\n    ? await pubg.getManyPlayerSeason({ players: players }, seasonid).catch(err => {\n        throw err;\n      })\n    : await pubg.getPlayerSeason(players, seasonid).catch(err => {\n        throw err;\n      });\n};\n\n/**\n * Combines the season stats of a group of players into their total aggregate\n * for each game mode, for a given season.\n * @param {PlayerSeason[]} playersStats an array of players that contains their stats for a season\n * @returns {Object} an object\n */\nconst getCombinedStats = playersStats => {\n  // Declare the combined stats obj\n  const combinedStats = {\n    solo: {},\n    soloFPP: {},\n    duo: {},\n    duoFPP: {},\n    squad: {},\n    squadFPP: {}\n  };\n\n  // Sum the stats of the season of each player to get the squad total stats\n  playersStats.forEach(player => {\n    _mergeWith(combinedStats.solo, player.season.stats.solo, _add);\n    _mergeWith(combinedStats.soloFPP, player.season.stats.soloFPP, _add);\n    _mergeWith(combinedStats.duo, player.season.stats.duo, _add);\n    _mergeWith(combinedStats.duoFPP, player.season.stats.duoFPP, _add);\n    _mergeWith(combinedStats.squad, player.season.stats.squad, _add);\n    _mergeWith(combinedStats.squadFPP, player.season.stats.squadFPP, _add);\n  });\n\n  return combinedStats;\n};\n\n/**\n * @description Get the matches that the given players have played together\n * @param {PlayerSeason[]} playersStats an array of players that contains their stats for a season\n * @returns {Object} containing arrays of matches that the players in [playersStats] have in common,\n * separated by game mode (duo, duoFPP, squad, squadFPP)\n */\nconst getMatchesTogether = playersStats => {\n  let matchesTogether = {};\n\n  matchesTogether.duo = playersStats[0].season.matches.matchesDuo;\n  matchesTogether.duoFPP = playersStats[0].season.matches.matchesDuoFPP;\n  matchesTogether.squad = playersStats[0].season.matches.matchesSquad;\n  matchesTogether.squadFPP = playersStats[0].season.matches.matchesSquadFPP;\n\n  for (let i = 1; i < playersStats.length; i++) {\n    // Find duo matches that the players have in common\n    matchesTogether.duo = _intersectionBy(\n      matchesTogether.duo,\n      playersStats[i].season.matches.matchesDuo,\n      'id'\n    );\n\n    matchesTogether.duo = matchesTogether.duo.map(match => match.fetch());\n\n    // Find duoFPP matches that the players have in common\n    matchesTogether.duoFPP = _intersectionBy(\n      matchesTogether.duoFPP,\n      playersStats[i].season.matches.matchesDuoFPP,\n      'id'\n    );\n\n    // Find squad matches that the players have in common\n    matchesTogether.squad = _intersectionBy(\n      matchesTogether.squad,\n      playersStats[i].season.matches.matchesSquad,\n      'id'\n    );\n\n    // Find squadFPP matches that the players have in common\n    matchesTogether.squadFPP = _intersectionBy(\n      matchesTogether.squadFPP,\n      playersStats[i].season.matches.matchesSquadFPP,\n      'id'\n    );\n  }\n\n  return matchesTogether;\n};\n\n/**\n * @description Get the stats of a group of players from the matches that they have played\n * together this season.\n * @param {String[]} playerNames Array of player names\n * @param {String} seasonid id of the season\n * @returns {Object} Object with stats of the players for each game mode\n */\nconst getSquadStatsFromMatches = async (matches, playerNames) => {\n  //Fetch all the matches\n  const fetchedMatches = await Promise.all(\n    matches.map(async match => {\n      return await pubg.getMatch(match.id);\n    })\n  );\n\n  const fullDuoMatches = fetchedMatches.filter(match => match.attributes.gameMode === 'duo');\n  const fullDuoFPPMatches = fetchedMatches.filter(match => match.attributes.gameMode === 'duo-fpp');\n  const fullSquadMatches = fetchedMatches.filter(match => match.attributes.gameMode === 'squad');\n  const fullSquadFPPMatches = fetchedMatches.filter(\n    match => match.attributes.gameMode === 'squad-fpp'\n  );\n\n  // Get the stats of the players from the duo matches\n  const duoMatchesStats = getPlayersStatsFromMatches(fullDuoMatches, playerNames);\n\n  // Get the stats of the players from the duo fpp matches\n  const duoFPPMatchesStats = getPlayersStatsFromMatches(fullDuoFPPMatches, playerNames);\n\n  // Get the stats of the players from the squad matches\n  const squadMatchesStats = getPlayersStatsFromMatches(fullSquadMatches, playerNames);\n\n  // Get the stats of the players from the squad fpp matches\n  const squadFPPMatchesStats = getPlayersStatsFromMatches(fullSquadFPPMatches, playerNames);\n\n  return {\n    duo: {\n      gamesPlayed: fullDuoMatches.length,\n      wins: duoMatchesStats[playerNames[0]].wins,\n      top10s: duoMatchesStats[playerNames[0]].top10s,\n      stats: duoMatchesStats\n    },\n    duoFPP: {\n      gamesPlayed: fullDuoFPPMatches.length,\n      wins: duoFPPMatchesStats[playerNames[0]].wins,\n      top10s: duoFPPMatchesStats[playerNames[0]].top10s,\n      stats: duoFPPMatchesStats\n    },\n    squad: {\n      gamesPlayed: fullSquadMatches.length,\n      wins: squadMatchesStats[playerNames[0]].wins,\n      top10s: squadMatchesStats[playerNames[0]].top10s,\n      stats: squadMatchesStats\n    },\n    squadFPP: {\n      gamesPlayed: fullSquadFPPMatches.length,\n      wins: squadFPPMatchesStats[playerNames[0]].wins,\n      top10s: squadFPPMatchesStats[playerNames[0]].top10s,\n      stats: squadFPPMatchesStats\n    }\n  };\n};\n\n/**\n * @description Return an object that contains an array for each game mode that contains the\n * aggregated stats of each squad member\n * @param {Match[]} matches An array of Match that the players have in common\n * @param {string[]} players Array of player names\n * @returns {Object} Object with player stats for each game mode\n */\nconst getPlayersStatsFromMatches = (matches, players) => {\n  const squadStats = {\n    teamTotal: {}\n  };\n\n  players.forEach(player => {\n    squadStats[player] = {\n      wins: 0,\n      top10s: 0,\n      alive: 0,\n      suicides: 0,\n      zoneDeaths: 0,\n      badges: []\n    };\n  });\n\n  // Traverse the matches\n  for (let i = 0; i < matches.length; i++) {\n    let { rosters } = matches[i].relationships;\n    // Traverse the rosters from the match\n    for (let j = 0; j < rosters.length; j++) {\n      let { participants } = rosters[j].relationships;\n      // If the roster contains any of the squad players process it, else -> search next roster\n      if (\n        players.some(p => {\n          for (let i = 0; i < participants.length; i++) {\n            if (p === participants[i].attributes.stats.name) {\n              return true;\n            }\n          }\n          return false;\n        })\n      ) {\n        // Traverse the participants in the roster\n        for (let k = 0; k < participants.length; k++) {\n          let { name } = participants[k].attributes.stats;\n          // If the participant is not part of the queried players, skip him\n          if (!players.includes(name)) continue;\n          // Merge the stats obj of the player with the match stats\n          _mergeWith(\n            squadStats[name],\n            participants[k].attributes.stats,\n            (objValue, srcValue, key, object, source, stack) =>\n              sumPlayerStats(objValue, srcValue, key, object, source, stack)\n          );\n\n          // Merge the stats of a player with the team total if its a squad\n          _mergeWith(\n            squadStats.teamTotal,\n            participants[k].attributes.stats,\n            (objValue, srcValue, key, object, source, stack) =>\n              sumPlayerStats(objValue, srcValue, key, object, source, stack)\n          );\n        }\n      } else {\n        continue;\n      }\n\n      // Roster was found, no need to keep iterating this match's rosters\n      break;\n    }\n  }\n\n  // Add the badges for the players and return the updated object\n  return calculateBadges(squadStats);\n};\n\n/**\n * Function used to merge the objects for the player stats from each match\n * Parameters are the ones used for lodash's mergeWith function\n */\nconst sumPlayerStats = (objValue, srcValue, key, object) => {\n  if (key === 'longestKill') {\n    return objValue > srcValue ? objValue : srcValue;\n  } else if (key === 'winPlace') {\n    srcValue === 1 ? object.wins++ : null;\n    srcValue <= 10 ? object.top10s++ : null;\n  } else if (key === 'deathType') {\n    srcValue === 'byzone'\n      ? object.zoneDeaths++\n      : srcValue === 'suicide'\n      ? object.suicide++\n      : srcValue === 'alive'\n      ? object.alive++\n      : null;\n  } else {\n    return _isNumber(objValue) ? objValue + srcValue : srcValue;\n  }\n};\n\n/**\n * @description Add the corresponding badges to each player in the squad stats\n * @param squadStats array of players and their stats for a given set of matches\n * @returns the updated squadStats obj with each player with their badges\n */\nconst calculateBadges = squadStats => {\n  if (_isEmpty(squadStats.teamTotal)) {\n    return squadStats;\n  } else {\n    // Get the top metrics and their value\n    const badges = [\n      { stat: 'assists', description: 'Most Assists' },\n      { stat: 'damageDealt', description: 'Most Damage Dealt' },\n      { stat: 'headshotKills', description: 'Most Headshots' },\n      { stat: 'kills', description: 'Most Kills' },\n      { stat: 'longestKill', description: 'Longest Kill' },\n      { stat: 'revives', description: 'Most Revives' },\n      { stat: 'roadKills', description: 'Most Road Kills' },\n      { stat: 'swimDistance', description: 'Most Distance Swimmed' },\n      { stat: 'teamKills', description: 'Most Teamkills' },\n      { stat: 'timeSurvived', description: 'Longest Time Survived' },\n      { stat: 'vehicleDestroys', description: 'Most Vehicles Destroyed' },\n      { stat: 'walkDistance', description: 'Most Distance Walked' },\n      { stat: 'suicides', description: 'Most Suicides' },\n      { stat: 'weaponsAcquired', description: 'Most Weapons Looted' },\n      { stat: 'zoneDeaths', description: 'Most Zone Deaths' }\n    ];\n\n    for (let i = 0; i < badges.length; i++) {\n      let topPlayer = getTopPlayer(squadStats, badges[i].stat);\n      if (topPlayer.player) {\n        squadStats[topPlayer.player].badges.push(_omit(_merge(topPlayer, badges[i]), 'player'));\n      }\n    }\n\n    return squadStats;\n  }\n};\n\n/**\n * @description Get the player name that has the highest score in a given metric\n * @param squadStats the stats obj of a group of players\n * @param metric the metric to be evaluated\n * @returns and object with the player index in the squadStat param and the value of the max metric\n */\nconst getTopPlayer = (squadStats, metric) => {\n  squadArray = _keys(squadStats); // Get an array of player names from the squad\n  let topValue = 0;\n  let topPlayer = null;\n  // Traverse the player names array\n  for (let i = 1; i < squadArray.length; i++) {\n    if (squadStats[squadArray[i]][metric] > topValue) {\n      topValue = squadStats[squadArray[i]][metric];\n      topPlayer = squadArray[i];\n    }\n  }\n\n  return { stat: metric, player: topPlayer, value: topValue };\n};\n\nmodule.exports = {\n  calculateBadges,\n  getPlayersSeasonStats,\n  getCombinedStats,\n  getMatchesTogether,\n  getSquadStatsFromMatches\n};\n"]},"metadata":{},"sourceType":"script"}