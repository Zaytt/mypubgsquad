{"version":3,"file":"static/development/pages/api/stats.js","sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/@babel/runtime-corejs2/core-js/array/is-array.js","webpack:///../node_modules/@babel/runtime-corejs2/core-js/json/stringify.js","webpack:///../node_modules/@babel/runtime-corejs2/core-js/promise.js","webpack:///../node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js","webpack:///../node_modules/@babel/runtime-corejs2/helpers/interopRequireDefault.js","webpack:///../node_modules/@babel/runtime-corejs2/regenerator/index.js","webpack:///./pages/api/stats/index.js","webpack:///./server/cache/cacheController.js","webpack:///./server/config/keys.js","webpack:///./server/config/keys_dev.js","webpack:///./server/core/statsAnalysis.js","webpack:///./server/pubg_api/pubg.js","webpack:///./server/routes/controllers/seasonsController.js","webpack:///./server/routes/controllers/statsController.js","webpack:///./server/routes/index.js","webpack:///external \"@zaytt/pubg\"","webpack:///external \"core-js/library/fn/array/is-array\"","webpack:///external \"core-js/library/fn/json/stringify\"","webpack:///external \"core-js/library/fn/promise\"","webpack:///external \"lodash\"","webpack:///external \"lodash.add\"","webpack:///external \"lodash.intersectionby\"","webpack:///external \"lodash.isempty\"","webpack:///external \"lodash.isnumber\"","webpack:///external \"lodash.keys\"","webpack:///external \"lodash.merge\"","webpack:///external \"lodash.mergewith\"","webpack:///external \"lodash.omit\"","webpack:///external \"memjs\"","webpack:///external \"regenerator-runtime\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = require('../../../../ssr-module-cache.js');\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tvar threw = true;\n \t\ttry {\n \t\t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n \t\t\tthrew = false;\n \t\t} finally {\n \t\t\tif(threw) delete installedModules[moduleId];\n \t\t}\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","module.exports = require(\"core-js/library/fn/array/is-array\");","module.exports = require(\"core-js/library/fn/json/stringify\");","module.exports = require(\"core-js/library/fn/promise\");","import _Promise from \"../../core-js/promise\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    _Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new _Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","module.exports = require(\"regenerator-runtime\");\n","const { stats } = require('../../../server/routes/index');\n\nexport default async (req, res) => {\n  return stats.getSquadStats(req, res);\n};\n","const memjs = require('memjs');\n\nlet serverStr =\n  process.env.NODE_ENV === 'production'\n    ? process.env.MEMCACHIER_USERNAME +\n      ':' +\n      process.env.MEMCACHIER_PASSWORD +\n      '@' +\n      process.env.MEMCACHIER_SERVERS\n    : 'localhost:11211';\nconst cache = memjs.Client.create(serverStr);\n\n/**\n * GETS THE PLAYER SEASONS FROM THE CACHE\n * @param {Array<String>} players Player names array to look up\n */\nconst getCachedPlayerSeasons = async players => {\n  const cachedPlayers = [];\n  const nonCachedPlayers = [];\n\n  await Promise.all(\n    players.map(player => {\n      return cache.get(`PlayerSeason:${player}`).then(({ value }) => {\n        if (value) cachedPlayers.push(JSON.parse(value));\n        else nonCachedPlayers.push(player);\n      });\n    })\n  ).catch(err => {\n    throw err;\n  });\n\n  return {\n    cachedPlayers,\n    nonCachedPlayers\n  };\n};\n\n/**\n * STORES THE PLAYER SEASONS IN CACHE\n * @param {Array<PlayerSeason>} playersSeasons Array or single element of PlayerSeasons\n * to store in the cache\n */\nconst setCachedPlayerSeasons = async playerSeasons => {\n  return Array.isArray(playerSeasons)\n    ? await Promise.all(\n        playerSeasons.map(ps => {\n          return cache.set(\n            `PlayerSeason:${ps.relationships.player.attributes.name}`,\n            JSON.stringify(ps),\n            { expires: 1800 }\n          );\n        })\n      ).catch(err => {\n        throw err;\n      })\n    : await cache\n        .set(\n          `PlayerSeason:${playerSeasons.relationships.player.attributes.name}`,\n          JSON.stringify(playerSeasons),\n          { expires: 1800 }\n        )\n        .then(res => true)\n        .catch(err => {\n          throw err;\n        });\n};\n\n/**\n * GETS THE SEASONS FROM THE CACHE\n */\nconst getCachedSeasons = () => {\n  return cache\n    .get(`Seasons`)\n    .then(({ value }) => JSON.parse(value))\n    .catch(err => {\n      throw err;\n    });\n};\n\n/**\n * STORES THE SEASONS IN THE CACHE\n * @param {Array<Seasons>} seasons array of Seasons objects\n * to store in the cache\n */\nconst setCachedSeasons = async seasons => {\n  return await cache\n    .set(`Seasons`, JSON.stringify(seasons), { expires: 86400 })\n    .then(res => true)\n    .catch(err => {\n      throw err;\n    });\n};\n\nmodule.exports = {\n  getCachedPlayerSeasons,\n  setCachedPlayerSeasons,\n  getCachedSeasons,\n  setCachedSeasons\n};\n","if (process.env.NODE_ENV === 'production') {\n  module.exports = require('./keys_prod');\n} else {\n  module.exports = require('./keys_dev');\n}\n","module.exports = {\n  mongoURI: 'mongodb://pubgleader:zayttleyedsulematz1t0@ds125578.mlab.com:25578/mypubgsquad-dev',\n  pubgApiKey:\n    'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJqdGkiOiIwMzg0YWNlMC0yZjJmLTAxMzctNjE0ZC01OWY4MWEyNmE3MzIiLCJpc3MiOiJnYW1lbG9ja2VyIiwiaWF0IjoxNTUzMzAwMjY4LCJwdWIiOiJibHVlaG9sZSIsInRpdGxlIjoicHViZyIsImFwcCI6Im15cHViZ3NxdWFkIn0.d_l0xzg8BB6J9uI7TAtzDbaHVqWlQWAa8PX98uUUPxg'\n};\n","const _mergeWith = require('lodash.mergewith');\nconst _add = require('lodash.add');\nconst _omit = require('lodash.omit');\nconst _isEmpty = require('lodash.isempty');\nconst _isNumber = require('lodash.isnumber');\nconst _merge = require('lodash.merge');\nconst _keys = require('lodash.keys');\nconst _intersectionBy = require('lodash.intersectionby');\nconst pubg = require('../pubg_api/pubg');\n\n/**\n * @description Returns an array containing info about a player and their season stats,\n * as well as the matches played this season\n * @param {string[]} playerNames array with a string of player names to lookup\n * @param {string} seasonid the PUBG season id\n * @returns {Array<Promise<PlayerSeason>>|<Promise<PlayerSeason>>} array containgin player info and season stats\n */\nconst getPlayersSeasonStats = async (playerNames, seasonid) => {\n  const players = await pubg.getPlayer({ name: playerNames });\n  return Array.isArray(players)\n    ? await pubg.getManyPlayerSeason({ players: players }, seasonid).catch(err => {\n        throw err;\n      })\n    : await pubg.getPlayerSeason(players, seasonid).catch(err => {\n        throw err;\n      });\n};\n\n/**\n * Combines the season stats of a group of players into their total aggregate\n * for each game mode, for a given season.\n * @param {PlayerSeason[]} playersStats an array of players that contains their stats for a season\n * @returns {Object} an object\n */\nconst getCombinedStats = playersStats => {\n  // Declare the combined stats obj\n  const combinedStats = {\n    solo: {},\n    soloFPP: {},\n    duo: {},\n    duoFPP: {},\n    squad: {},\n    squadFPP: {}\n  };\n\n  // Sum the stats of the season of each player to get the squad total stats\n  playersStats.forEach(player => {\n    _mergeWith(combinedStats.solo, player.season.stats.solo, _add);\n    _mergeWith(combinedStats.soloFPP, player.season.stats.soloFPP, _add);\n    _mergeWith(combinedStats.duo, player.season.stats.duo, _add);\n    _mergeWith(combinedStats.duoFPP, player.season.stats.duoFPP, _add);\n    _mergeWith(combinedStats.squad, player.season.stats.squad, _add);\n    _mergeWith(combinedStats.squadFPP, player.season.stats.squadFPP, _add);\n  });\n\n  return combinedStats;\n};\n\n/**\n * @description Get the matches that the given players have played together\n * @param {PlayerSeason[]} playersStats an array of players that contains their stats for a season\n * @returns {Object} containing arrays of matches that the players in [playersStats] have in common,\n * separated by game mode (duo, duoFPP, squad, squadFPP)\n */\nconst getMatchesTogether = playersStats => {\n  let matchesTogether = {};\n\n  matchesTogether.duo = playersStats[0].season.matches.matchesDuo;\n  matchesTogether.duoFPP = playersStats[0].season.matches.matchesDuoFPP;\n  matchesTogether.squad = playersStats[0].season.matches.matchesSquad;\n  matchesTogether.squadFPP = playersStats[0].season.matches.matchesSquadFPP;\n\n  for (let i = 1; i < playersStats.length; i++) {\n    // Find duo matches that the players have in common\n    matchesTogether.duo = _intersectionBy(\n      matchesTogether.duo,\n      playersStats[i].season.matches.matchesDuo,\n      'id'\n    );\n\n    matchesTogether.duo = matchesTogether.duo.map(match => match.fetch());\n\n    // Find duoFPP matches that the players have in common\n    matchesTogether.duoFPP = _intersectionBy(\n      matchesTogether.duoFPP,\n      playersStats[i].season.matches.matchesDuoFPP,\n      'id'\n    );\n\n    // Find squad matches that the players have in common\n    matchesTogether.squad = _intersectionBy(\n      matchesTogether.squad,\n      playersStats[i].season.matches.matchesSquad,\n      'id'\n    );\n\n    // Find squadFPP matches that the players have in common\n    matchesTogether.squadFPP = _intersectionBy(\n      matchesTogether.squadFPP,\n      playersStats[i].season.matches.matchesSquadFPP,\n      'id'\n    );\n  }\n\n  return matchesTogether;\n};\n\n/**\n * @description Get the stats of a group of players from the matches that they have played\n * together this season.\n * @param {String[]} playerNames Array of player names\n * @param {String} seasonid id of the season\n * @returns {Object} Object with stats of the players for each game mode\n */\nconst getSquadStatsFromMatches = async (matches, playerNames) => {\n  //Fetch all the matches\n  const fetchedMatches = await Promise.all(\n    matches.map(async match => {\n      return await pubg.getMatch(match.id);\n    })\n  );\n\n  const fullDuoMatches = fetchedMatches.filter(match => match.attributes.gameMode === 'duo');\n  const fullDuoFPPMatches = fetchedMatches.filter(match => match.attributes.gameMode === 'duo-fpp');\n  const fullSquadMatches = fetchedMatches.filter(match => match.attributes.gameMode === 'squad');\n  const fullSquadFPPMatches = fetchedMatches.filter(\n    match => match.attributes.gameMode === 'squad-fpp'\n  );\n\n  // Get the stats of the players from the duo matches\n  const duoMatchesStats = getPlayersStatsFromMatches(fullDuoMatches, playerNames);\n\n  // Get the stats of the players from the duo fpp matches\n  const duoFPPMatchesStats = getPlayersStatsFromMatches(fullDuoFPPMatches, playerNames);\n\n  // Get the stats of the players from the squad matches\n  const squadMatchesStats = getPlayersStatsFromMatches(fullSquadMatches, playerNames);\n\n  // Get the stats of the players from the squad fpp matches\n  const squadFPPMatchesStats = getPlayersStatsFromMatches(fullSquadFPPMatches, playerNames);\n\n  return {\n    duo: {\n      gamesPlayed: fullDuoMatches.length,\n      wins: duoMatchesStats[playerNames[0]].wins,\n      top10s: duoMatchesStats[playerNames[0]].top10s,\n      stats: duoMatchesStats\n    },\n    duoFPP: {\n      gamesPlayed: fullDuoFPPMatches.length,\n      wins: duoFPPMatchesStats[playerNames[0]].wins,\n      top10s: duoFPPMatchesStats[playerNames[0]].top10s,\n      stats: duoFPPMatchesStats\n    },\n    squad: {\n      gamesPlayed: fullSquadMatches.length,\n      wins: squadMatchesStats[playerNames[0]].wins,\n      top10s: squadMatchesStats[playerNames[0]].top10s,\n      stats: squadMatchesStats\n    },\n    squadFPP: {\n      gamesPlayed: fullSquadFPPMatches.length,\n      wins: squadFPPMatchesStats[playerNames[0]].wins,\n      top10s: squadFPPMatchesStats[playerNames[0]].top10s,\n      stats: squadFPPMatchesStats\n    }\n  };\n};\n\n/**\n * @description Return an object that contains an array for each game mode that contains the\n * aggregated stats of each squad member\n * @param {Match[]} matches An array of Match that the players have in common\n * @param {string[]} players Array of player names\n * @returns {Object} Object with player stats for each game mode\n */\nconst getPlayersStatsFromMatches = (matches, players) => {\n  const squadStats = {\n    teamTotal: {}\n  };\n\n  players.forEach(player => {\n    squadStats[player] = {\n      wins: 0,\n      top10s: 0,\n      alive: 0,\n      suicides: 0,\n      zoneDeaths: 0,\n      badges: []\n    };\n  });\n\n  // Traverse the matches\n  for (let i = 0; i < matches.length; i++) {\n    let { rosters } = matches[i].relationships;\n    // Traverse the rosters from the match\n    for (let j = 0; j < rosters.length; j++) {\n      let { participants } = rosters[j].relationships;\n      // If the roster contains any of the squad players process it, else -> search next roster\n      if (\n        players.some(p => {\n          for (let i = 0; i < participants.length; i++) {\n            if (p === participants[i].attributes.stats.name) {\n              return true;\n            }\n          }\n          return false;\n        })\n      ) {\n        // Traverse the participants in the roster\n        for (let k = 0; k < participants.length; k++) {\n          let { name } = participants[k].attributes.stats;\n          // If the participant is not part of the queried players, skip him\n          if (!players.includes(name)) continue;\n          // Merge the stats obj of the player with the match stats\n          _mergeWith(\n            squadStats[name],\n            participants[k].attributes.stats,\n            (objValue, srcValue, key, object, source, stack) =>\n              sumPlayerStats(objValue, srcValue, key, object, source, stack)\n          );\n\n          // Merge the stats of a player with the team total if its a squad\n          _mergeWith(\n            squadStats.teamTotal,\n            participants[k].attributes.stats,\n            (objValue, srcValue, key, object, source, stack) =>\n              sumPlayerStats(objValue, srcValue, key, object, source, stack)\n          );\n        }\n      } else {\n        continue;\n      }\n\n      // Roster was found, no need to keep iterating this match's rosters\n      break;\n    }\n  }\n\n  // Add the badges for the players and return the updated object\n  return calculateBadges(squadStats);\n};\n\n/**\n * Function used to merge the objects for the player stats from each match\n * Parameters are the ones used for lodash's mergeWith function\n */\nconst sumPlayerStats = (objValue, srcValue, key, object) => {\n  if (key === 'longestKill') {\n    return objValue > srcValue ? objValue : srcValue;\n  } else if (key === 'winPlace') {\n    srcValue === 1 ? object.wins++ : null;\n    srcValue <= 10 ? object.top10s++ : null;\n  } else if (key === 'deathType') {\n    srcValue === 'byzone'\n      ? object.zoneDeaths++\n      : srcValue === 'suicide'\n      ? object.suicide++\n      : srcValue === 'alive'\n      ? object.alive++\n      : null;\n  } else {\n    return _isNumber(objValue) ? objValue + srcValue : srcValue;\n  }\n};\n\n/**\n * @description Add the corresponding badges to each player in the squad stats\n * @param squadStats array of players and their stats for a given set of matches\n * @returns the updated squadStats obj with each player with their badges\n */\nconst calculateBadges = squadStats => {\n  if (_isEmpty(squadStats.teamTotal)) {\n    return squadStats;\n  } else {\n    // Get the top metrics and their value\n    const badges = [\n      { stat: 'assists', description: 'Most Assists' },\n      { stat: 'damageDealt', description: 'Most Damage Dealt' },\n      { stat: 'headshotKills', description: 'Most Headshots' },\n      { stat: 'kills', description: 'Most Kills' },\n      { stat: 'longestKill', description: 'Longest Kill' },\n      { stat: 'revives', description: 'Most Revives' },\n      { stat: 'roadKills', description: 'Most Road Kills' },\n      { stat: 'swimDistance', description: 'Most Distance Swimmed' },\n      { stat: 'teamKills', description: 'Most Teamkills' },\n      { stat: 'timeSurvived', description: 'Longest Time Survived' },\n      { stat: 'vehicleDestroys', description: 'Most Vehicles Destroyed' },\n      { stat: 'walkDistance', description: 'Most Distance Walked' },\n      { stat: 'suicides', description: 'Most Suicides' },\n      { stat: 'weaponsAcquired', description: 'Most Weapons Looted' },\n      { stat: 'zoneDeaths', description: 'Most Zone Deaths' }\n    ];\n\n    for (let i = 0; i < badges.length; i++) {\n      let topPlayer = getTopPlayer(squadStats, badges[i].stat);\n      if (topPlayer.player) {\n        squadStats[topPlayer.player].badges.push(_omit(_merge(topPlayer, badges[i]), 'player'));\n      }\n    }\n\n    return squadStats;\n  }\n};\n\n/**\n * @description Get the player name that has the highest score in a given metric\n * @param squadStats the stats obj of a group of players\n * @param metric the metric to be evaluated\n * @returns and object with the player index in the squadStat param and the value of the max metric\n */\nconst getTopPlayer = (squadStats, metric) => {\n  squadArray = _keys(squadStats); // Get an array of player names from the squad\n  let topValue = 0;\n  let topPlayer = null;\n  // Traverse the player names array\n  for (let i = 1; i < squadArray.length; i++) {\n    if (squadStats[squadArray[i]][metric] > topValue) {\n      topValue = squadStats[squadArray[i]][metric];\n      topPlayer = squadArray[i];\n    }\n  }\n\n  return { stat: metric, player: topPlayer, value: topValue };\n};\n\nmodule.exports = {\n  calculateBadges,\n  getPlayersSeasonStats,\n  getCombinedStats,\n  getMatchesTogether,\n  getSquadStatsFromMatches\n};\n","const { pubgApiKey } = require('../config/keys');\n\n// Require model and initiate client with api key\nconst pubg = require('@zaytt/pubg');\nconst pubgClient = new pubg.Client(pubgApiKey, 'steam');\n\nmodule.exports = pubgClient;\n","const pubgAPI = require('../../pubg_api/pubg');\nconst { getCachedSeasons, setCachedSeasons } = require('../../cache/cacheController');\n\nconst storeSeasons = async () => {\n  seasons = await pubgAPI.getSeasons();\n  await setCachedSeasons(seasons)\n    .then(res => console.log('Stored Seasons in Cache'))\n    .catch(err => {\n      console.warn('Failed to store seasons in cache');\n      throw err;\n    });\n};\n\nconst getSeasons = async () => {\n  let seasons = await getCachedSeasons();\n\n  if (seasons) {\n    return seasons;\n  } else {\n    seasons = await pubgAPI.getSeasons();\n    await setCachedSeasons(seasons).catch(err => {\n      throw err;\n    });\n    return seasons;\n  }\n};\n\nconst getCurrentSeason = async () => {\n  const seasons = await getSeasons();\n  return seasons.filter(season => season.attributes.isCurrentSeason)[0];\n};\n\nmodule.exports = {\n  storeSeasons,\n  getSeasons,\n  getCurrentSeason\n};\n","const _ = require('lodash');\nconst seasonsController = require('./seasonsController');\nconst cache = require('../../cache/cacheController');\n\nconst { getPlayersSeasonStats, getSquadStatsFromMatches } = require('../../core/statsAnalysis');\n\nconst test = async (req, res) => {\n  res.json(req.query);\n};\n/**\n * @route GET /api/stats?squad=[playernames]&season=[seasonid]\n * @description Returns the stats of a squad of players for a given season\n * @returns {<Array<PlayerSeasons>>} An array of filtered pubg.js PlayerSeasons objects.\n * @access Public\n */\nconst getSquadStats = async (req, res) => {\n  let { squad, season, refresh } = req.query;\n  if (!season) {\n    let currentSeason = await seasonsController.getCurrentSeason();\n    season = currentSeason.id;\n  }\n\n  const playerNamesArray = squad.split(',');\n\n  try {\n    let playersStats, fetchedPlayers;\n    // If refresh == true, skip checking for cached players\n    if (refresh) {\n      fetchedPlayers = await getPlayersSeasonStats(playerNamesArray, season);\n      playersStats = Array.isArray(fetchedPlayers)\n        ? fetchedPlayers.map(p =>\n            _.pick(p, ['attributes', 'relationships.player', 'relationships.season'])\n          )\n        : _.pick(fetchedPlayers, ['attributes', 'relationships.player', 'relationships.season']);\n    } else {\n      // Check cache for stored players\n      let { cachedPlayers, nonCachedPlayers } = await cache.getCachedPlayerSeasons(\n        playerNamesArray\n      );\n      // If there's non cached players, fetch them\n      if (nonCachedPlayers.length > 0) {\n        fetchedPlayers = await getPlayersSeasonStats(nonCachedPlayers, season);\n        const newCachedPlayers = Array.isArray(fetchedPlayers)\n          ? fetchedPlayers.map(p =>\n              _.pick(p, ['attributes', 'relationships.player', 'relationships.season'])\n            )\n          : _.pick(fetchedPlayers, ['attributes', 'relationships.player', 'relationships.season']);\n        // Cache the fetched players\n        await cache.setCachedPlayerSeasons(newCachedPlayers);\n        cachedPlayers = cachedPlayers.concat(newCachedPlayers);\n      }\n      playersStats = cachedPlayers;\n    }\n    res.status(200).json(playersStats);\n  } catch (error) {\n    if (error.message.status) {\n      res.status(error.message.status).json(error.message);\n    } else if (error.status) {\n      res.status(error.status).json(error);\n    } else {\n      res.status(error).json(error.message);\n    }\n  }\n};\n\n/**\n * @route GET /api/stats/matches\n * @description returns the stats of players from the matches that they have played together this season\n */\nconst getSquadMatchesStats = async (req, res) => {\n  let { matches, playerNames } = req.body;\n  try {\n    res.status(200).json(await getSquadStatsFromMatches(matches, playerNames));\n  } catch (error) {\n    console.log(error);\n    if (error.status) {\n      res.status(error.status).json({\n        error: error.status,\n        message: error.message\n      });\n    } else {\n      res.status(500).json({\n        error: 500,\n        message: error.message\n      });\n    }\n  }\n};\n\nmodule.exports = {\n  test,\n  getSquadStats,\n  getSquadMatchesStats\n};\n","const seasons = require('./controllers/seasonsController');\nconst stats = require('./controllers/statsController');\n\nmodule.exports = {\n  seasons,\n  stats\n};\n","module.exports = require(\"@zaytt/pubg\");","module.exports = require(\"core-js/library/fn/array/is-array\");","module.exports = require(\"core-js/library/fn/json/stringify\");","module.exports = require(\"core-js/library/fn/promise\");","module.exports = require(\"lodash\");","module.exports = require(\"lodash.add\");","module.exports = require(\"lodash.intersectionby\");","module.exports = require(\"lodash.isempty\");","module.exports = require(\"lodash.isnumber\");","module.exports = require(\"lodash.keys\");","module.exports = require(\"lodash.merge\");","module.exports = require(\"lodash.mergewith\");","module.exports = require(\"lodash.omit\");","module.exports = require(\"memjs\");","module.exports = require(\"regenerator-runtime\");"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxFA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACNA;;;;;;;;;;;;;;;;;;;;ACAA;AAAA;AACA;AACA,4EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AAQA;AAEA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAFA;AAAA;AAMA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAdA;AAAA;AAgBA;AACA;AAFA;AACA;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAqBA;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAIA;AAGA;AAAA;AAEA;AAEA;AACA;AACA;AAbA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAiBA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAvBA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAyBA;;;;;AAGA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAPA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAQA;AACA;AACA;AACA;AACA;AAJA;;;;;;;;;;;;;;AC7FA,aAEA;AACA;AACA;;;;;;;;;;;;;;ACJA;AACA;AACA;AAFA;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAFA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AANA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAOA;AACA;AACA;AATA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAWA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AASA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAEA;;;;;;;;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAAA;AACA;AAEA;AACA;AAMA;AACA;AAMA;AAKA;AACA;AACA;AACA;AAEA;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAJA;AAEA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAzBA;AA4BA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAnBA;AACA;AA5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAuDA;;;;;;;;;AAOA;AACA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AAEA;AAAA;AACA;AADA;AAAA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAGA;AAGA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AA1CA;AACA;AADA;AAGA;AACA;AADA;AAAA;AAmCA;AACA;AApCA;AAuCA;AAvCA;AAwCA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAC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","sourceRoot":""}